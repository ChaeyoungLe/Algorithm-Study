## 슬라이딩 윈도우 알고리즘

: 고정 사이즈의 윈도우가 이동하면서 윈도우 내에 있는 데이터를 이용해 문제를 풀이한다.

교집합의 정보를 공유하고, 차이가 나는 양쪽 끝 원소만 갱신하는 방법

⇒ 투 포인터 알고리즘과 연동하여 많이 쓰이나.

ex) 1- 7 까지 이루어진 숫자 배열에서 

A[i] + A[i+1] + A[i+2] 형식으로 연속적인 3개의 숫자의 합이 최대값을 구한다고 가정해보면

[1, 2, 3], 4, 5, 6, 7

1, [2, 3, 4], 5, 6, 7

1, 2, [3, 4, 5], 6, 7

1, 2, 3, [4, 5, 6], 7

1, 2, 3, 4, [5, 6, 7]

[1,2,3] ⇒ [2,3,4] ⇒ … [5,6,7]

**최소한의 계산으로 배열의 합을 구하는 방법?**

처음 [1,2,3]의 합을 구한다.

[2,3,4]는 [1,2,3] 배열에서 맨 앞 값이 빠지고 4가 들어온다. 

⇒ 6-1+4로 계산!

**투 포인트 알고리즘과의 차이점**

**투 포인트 알고리즘은** 구간의 넓이가 조건에 따라 **유동적으로 변하며**, 슬라이딩 알고리즘의 구간의 넓이는 **고정되어 있다.**

## 스택과 큐

**스택**

: 삽입과 삭제 연산이 후입선출(Last-in First-out)로 이루어지는 구조

→ 삽입과 삭제가 한 쪽에서만 일어난다.

→ **DFS(깊이 우선 탐색), 백트래킹 종류 효과적**

→ 재귀 함수 알고리즘 원리와 일맥상통

재귀함수  메서드 : 연속적인 자기 호출

<위치>

top : 삽입과 삭제가 일어나는 위치

<연산>

push : top 위치에 새로운 데이터를 삽입(수를 넣을 때 반드시 오름차순)

pop : top 위치에 현재 있는 데이터를 삭제하고 확인

peek : top 위치에 현재 있는 데이터를 단순 확인

**큐**

: 삽입과 삭제 연산이 선입선출(FIFO)로 이루어지는 구조.

→ 먼저 들어온 데이터가 먼저 나감.

→ 삽입과 삭제가 양방향

→ **너비우선탐색(BFS)**에 자주 사용

<위치>

rear : 큐에서 가장 끝 데이터를 가리키는 영역

front : 큐에서 가장 앞의 데이터를 가리키는 영역

add : rear 부분에 새로운 데이터를 삽입

poll : front 부분에 있는 데이터를 삭제하고 확인하는 연산

peek : 큐의 맨 앞(front_에 있는 데이터를 확인 할 때 사용하는 연산.

*우선순위 큐

: 값이 들어가는 순서와 상관 없이 우선순위가 높은 데이터가 먼저 나오는 자료구조

큐 설정에 따라 front에 항상 최댓값 또는 최솟값이 위치

→ heap을 이용해 구현
